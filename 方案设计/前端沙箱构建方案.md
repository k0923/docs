这是一份为你整理的**基于 WebAssembly 的 React 在线编译与执行完整技术方案**。

该方案专为“小体量工程”设计，满足**用户自定义组件**、**Tailwind CSS v4 支持**以及**高安全性**的需求。

---

### 一、 核心架构设计

整个系统完全运行在浏览器端，无需 Node.js 后端服务。

```mermaid
graph TD
    User[用户输入] --> State[React State (源码字符串)]
    State --> Compiler[构建层 (ESBuild-Wasm)]
    
    subgraph Compiler [构建与依赖]
        P1[虚拟文件系统 Plugin] --> |读取| State
        P2[依赖解析 Plugin] --> |请求| CDN[esm.sh / unpkg]
        CDN --> |缓存| Cache[IndexedDB]
    end
    
    Compiler --> |输出| Bundle[CommonJS/IIFE 字符串]
    
    Bundle --> Sandbox[执行层 (Iframe)]
    
    subgraph Sandbox [沙箱环境]
        HTML[HTML模版]
        TW[Tailwind v4 Runtime] --> |监听| DOM
        React[React Runtime] --> |渲染| DOM
    end
    
    Sandbox --> |PostMessage| Host[宿主环境]
```

---

### 二、 技术选型

| 模块 | 技术栈 | 理由 |
| :--- | :--- | :--- |
| **编译器** | **ESBuild-Wasm** | Go 编写，编译为 Wasm，浏览器端构建速度最快 (毫秒级)。 |
| **依赖管理** | **esm.sh** + **Fetch** | 针对浏览器优化的 CDN，自动处理依赖树；配合 IndexedDB 做缓存。 |
| **样式引擎** | **Tailwind CSS v4 Runtime** | 使用 `@tailwindcss/browser` 脚本，实时扫描 DOM 生成样式，无需编译 CSS。 |
| **沙箱容器** | **Iframe (srcDoc)** | 提供原生进程级隔离，防止全局污染和安全攻击。 |
| **通信机制** | **PostMessage** | 穿越沙箱边界的安全通信协议。 |

---

### 三、 详细实现步骤

#### 1. 构建层：ESBuild 编译器封装

创建一个 `bundler.ts` 服务，用于将用户输入的 JSX 代码转换为浏览器可执行的 JS。

```typescript
import * as esbuild from 'esbuild-wasm';

// 1. 初始化 (单例模式)
let initialized = false;
export const startService = async () => {
  if (!initialized) {
    await esbuild.initialize({
      worker: true,
      wasmURL: 'https://unpkg.com/esbuild-wasm@0.19.0/esbuild.wasm',
    });
    initialized = true;
  }
};

// 2. 编译函数
export const bundle = async (rawCode: string) => {
  if (!initialized) await startService();

  try {
    const result = await esbuild.build({
      entryPoints: ['index.js'],
      bundle: true,
      write: false,
      plugins: [unpkgPathPlugin(), fetchPlugin(rawCode)], // 自定义插件处理 import
      define: {
        'process.env.NODE_ENV': '"production"',
        global: 'window',
      },
      jsxFactory: '_React.createElement', // 避免与 Iframe 内的 React 冲突（可选）
      jsxFragment: '_React.Fragment',
    });
    return { code: result.outputFiles[0].text, err: '' };
  } catch (err) {
    return { code: '', err: err.message };
  }
};
```
*注：`unpkgPathPlugin` 和 `fetchPlugin` 用于拦截 import 路径并从 CDN 拉取内容，建议结合 `localforage` 做一层 IndexedDB 缓存，否则网络请求会很慢。*

#### 2. 执行层：沙箱 HTML 模版构造

这是集成的关键。我们需要构造一个 HTML 字符串，包含 Tailwind v4 环境、React 依赖和用户编译后的代码。

```javascript
const buildHtml = (compiledCode, userTailwindConfig) => {
  return `
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <!-- 1. 安全策略：允许脚本，允许 CDN，禁止同源 -->
      <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' https://unpkg.com https://esm.sh blob:;">
      
      <!-- 2. 引入 React 依赖 (UMD 模式最简单，或通过 import map) -->
      <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
      <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
      
      <!-- 3. 引入 Tailwind v4 Runtime -->
      <script src="https://unpkg.com/@tailwindcss/browser@4"></script>
      
      <!-- 4. 用户自定义的主题配置 -->
      <style type="text/tailwindcss">
        @theme {
          ${userTailwindConfig || '--color-brand: #3b82f6;'} 
        }
      </style>
    </head>
    <body>
      <div id="root"></div>
      
      <script>
        // 错误捕获
        window.addEventListener('error', (e) => {
          e.preventDefault();
          window.parent.postMessage({ type: 'ERROR', message: e.message }, '*');
        });

        // 监听来自宿主的数据
        window.addEventListener('message', (event) => {
          if (event.data.type === 'EXECUTE') {
             try {
                // 这里的 _React 是为了配合 esbuild 的 define
                const _React = window.React;
                const _ReactDOM = window.ReactDOM;
                
                // 执行编译后的代码
                eval(event.data.code);
             } catch (err) {
                console.error(err);
             }
          }
        });
      </script>
    </body>
    </html>
  `;
};
```

#### 3. 宿主组件：Previewer

将上述逻辑组装成一个 React 组件。

```jsx
import React, { useRef, useEffect } from 'react';
import { bundle } from './bundler';

const Preview = ({ code, cssConfig }) => {
  const iframeRef = useRef(null);

  useEffect(() => {
    // 1. 初始化 Iframe 内容 (仅执行一次或当 HTML 结构变动时)
    const html = buildHtml('', cssConfig);
    if (iframeRef.current) {
      iframeRef.current.srcdoc = html;
    }
  }, [cssConfig]);

  useEffect(() => {
    const timer = setTimeout(async () => {
      // 2. 编译代码
      const { code: compiledJS, err } = await bundle(code);
      
      if (err) {
        console.error('Build Error:', err);
        return;
      }

      // 3. 发送给 Iframe 执行
      if (iframeRef.current && iframeRef.current.contentWindow) {
        iframeRef.current.contentWindow.postMessage({
          type: 'EXECUTE',
          code: compiledJS
        }, '*');
      }
    }, 750); // 防抖，避免输入时频繁编译

    return () => clearTimeout(timer);
  }, [code]);

  return (
    <div className="preview-wrapper">
      <iframe
        ref={iframeRef}
        title="preview"
        // 核心安全配置：禁止 allow-same-origin
        sandbox="allow-scripts allow-forms allow-modals" 
        style={{ width: '100%', height: '100%', border: 'none' }}
      />
    </div>
  );
};

export default Preview;
```

---

### 四、 安全与隔离策略 (重点)

1.  **Iframe Sandbox**:
    *   必须设置 `sandbox="allow-scripts"`。
    *   **绝对不要**设置 `allow-same-origin`。这保证了 Iframe 的源为 `null`，无法访问宿主的 `localStorage`、`cookie` 或 DOM。

2.  **通信安全**:
    *   宿主 -> Iframe: 通过 `postMessage` 发送编译后的代码。
    *   Iframe -> 宿主: 通过 `postMessage` 发送运行时错误、高度变化等。

3.  **用户输入清洗**:
    *   虽然在沙箱中，但仍建议在 ESBuild 阶段过滤掉某些危险包的导入（如 `process` 等 node 专用包）。

---

### 五、 方案优缺点总结

**优点：**
1.  **轻量级**：无需后端构建服务，节省服务器成本。
2.  **安全性高**：Iframe 沙箱 + 跨域隔离，有效防止恶意代码攻击。
3.  **体验好**：支持 React + Tailwind v4 实时预览，符合现代开发习惯。
4.  **可扩展**：通过 CDN 插件，理论上支持任何 npm 包的导入。

**缺点与挑战：**
1.  **首屏速度**：初次加载 Wasm 文件 (约 8MB) 和 React 依赖较慢（必须上 IndexedDB 缓存）。
2.  **浏览器兼容性**：需要支持 Wasm 和 ES Modules 的现代浏览器。
3.  **复杂依赖限制**：某些强依赖 Node.js API (fs, net) 的库无法在浏览器端运行，需要 mock 或报错处理。

这是一个经过社区验证（CodeSandbox, Udemy 等）且完全可落地的成熟方案。